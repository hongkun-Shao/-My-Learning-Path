# Linux多进程开发
## 一.进程概述
### 1.进程与程序
1. **进程是正在运行的程序的实例**。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。
2. **可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。**从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。
3. **程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：**
    * 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）
    * 机器语言指令：对程序算法进行编码。
    * 程序入口地址：标识程序开始执行时的起始指令位置。
    * 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。
    * 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。
    * 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。
    * 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。
### 2.单道和多道程序设计
1. 单道程序，即在计算机内存中只允许一个的程序运行。
2. 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。
3. 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。
4. 在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。
### 3.时间片
1. 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。
2. 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。
### 4.并行和并发
1. 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。
2. 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。  

**notice:并行的进程也可以并发,并发是两个队列交替使用一台咖啡机。
并行是两个队列同时使用两台咖啡机。**
### **5.进程控制块(PCB)**
1. 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。
2. 在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可：
    * 进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数
    * 进程的状态：有就绪、运行、挂起、停止等状态
    * 进程切换时需要保存和恢复的一些CPU寄存器
    * 描述虚拟地址空间的信息
    * 描述控制终端的信息
    * 当前工作目录（Current Working Directory）
    * umask 掩码
    * 文件描述符表，包含很多指向 file 结构体的指针
    * 和信号相关的信息
    * 用户 id 和组 id
    * 会话（Session）和进程组
### 6.进程的状态(5个)
进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态。 
1. 运行态：进程占有处理器正在运行
2. 就绪态：进程具备运行条件，等待系统分配处理器以便运
行。当进程已分配到除CPU以外的所有必要资源后，只要再
获得CPU，便可立即执行。在一个系统中处于就绪状态的进
程可能有多个，通常将它们排成一个队列，称为就绪队列
3. 阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程
不具备运行条件，正在等待某个事件的完成
4. 新建态：进程刚被创建时的状态，尚未进入就绪队列
5. 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。

## 二.进程的创建(fork)
系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成
进程树结构模型。
```
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

&emsp;&emsp;**该函数的每次调用都返回两次**，在父进程中返回的是子进程的PID， 在子进程中则返回0。该返回值是后续代码判断当前进程是父进程还是子进程的依据。fork调用失败时返回-1，并设置errno。  

&emsp;&emsp;fork函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和标志寄存器的值。但也有许多属性被赋予了新的值，比如该进程的PPID被设置成原进程的PID，信号位图被清除（原进程设置的信号处理函数不再对
新进程起作用）。  

&emsp;&emsp;子进程的代码与父进程完全相同，同时它还会复制父进程的数据（堆数据、栈数据和静态数据）。数据的复制采用的是所谓的写时复制（copy on writte），即只有在任一进程（父进程或子进程）对数据执行了写操作时，复制才会发生（先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据）。即便如此，如果我们在程序中分配了大
量内存，那么使用fork时也应当十分谨慎，尽量避免没必要的内存分配
和数据复制。  

&emsp;&emsp;此外，创建子进程后，父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加1。不仅如此，父进程的用户根目录、当前工作目录等变量的引用计数均会加1。

## 三.exec函数族
&emsp;&emsp;exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。
```
#include＜unistd.h＞
extern char**environ;
int execl(const char*path,const char*arg,...);
int execlp(const char*file,const char*arg,...);
int execle(const char*path,const char*arg,...,char*const envp[]);
int execv(const char*path,char*const argv[]);
int execvp(const char*file,char*const argv[]);
int execve(const char*path,char*const argv[],char*const envp[]);
l(list) 参数地址列表，以空指针结尾
v(vector) 存有各参数地址的指针数组的地址
p(path) 按 PATH 环境变量指定的目录搜索可执行文件
e(environment) 存有环境变量字符串地址的指针数组的地址
```
&emsp;&emsp;path参数指定可执行文件的完整路径，file参数可以接受文件名，该文件的具体位置则在环境变量PATH中搜寻。arg接受可变参数，argv则接受参数数组，它们都会被传递给新程序（path或file指定的程序）的main函数。envp参数用于设置新程序的环境变量。如果未设置它，则新程序将使用由全局变量environ指定的环境变量。  

&emsp;&emsp;一般情况下，exec函数是不返回的，除非出错。它出错时返回-1，并设置errno。如果没出错，则原程序中exec调用之后的代码都不会执行，因为此时原程序已经被exec的参数指定的程序完全替换（包括代码和数据）。  

&emsp;&emsp;exec函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性。   
## 四.进程的退出和回收原理及可能转化为的状态
### 1.进程退出
```
#include <stdlib.h>
void exit(int status);

#include <unistd.h>
void _exit(int status);

exit是C的库函数，而_exit是Linux的库函数
进程运行->调用退出处理函数->刷新I/O缓冲->关闭文件描述符->调用_exit()系统调用->进程终止运行
或者
进程运行->调用_exit()系统调用->进程终止运行
```

### 2.孤儿进程
1. 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进（Orphan Process）。
2. 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束
了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。
3. 因此孤儿进程并不会有什么危害。

### 3.僵尸进程
1. 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。
2. 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。
3. 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。

### 4.进程回收
1. 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。
2. 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。
3. wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。
4. 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。


### 5.wait()和waitpid()函数
```
#include＜sys/types.h＞
#include＜sys/wait.h＞
pid_t wait(int*stat_loc);
pid_t waitpid(pid_t pid,int*stat_loc,int options);
```
&emsp;&emsp;wait函数将阻塞进程，直到该进程的某个子进程结束运行为止。它
返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于
stat_loc参数指向的内存中。sys/wait.h头文件中定义了几个宏来帮助解释子进程的退出状态信息  
* WIFEXITED(status) 非0，进程正常退出
* WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）
* WIFSIGNALED(status) 非0，进程异常终止
* WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号
* WIFSTOPPED(status) 非0，进程处于暂停状态
* WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号
* WIFCONTINUED(status) 非0，进程暂停后已经继续运行


&emsp;&emsp;wait函数的阻塞特性显然不是服务器程序期望的，而waitpid函数解
决了这个问题。waitpid只等待由pid参数指定的子进程。如果pid取值
为-1，那么它就和wait函数相同，即等待任意一个子进程结束。stat_loc
参数的含义和wait函数的stat_loc参数相同。options参数可以控制waitpid函数的行为。该参数最常用的取值是WNOHANG。当options的取值是WNOHANG时，waitpid调用将是非阻塞的：如果pid指定的目标子进程
还没有结束或意外终止，则waitpid立即返回0；如果目标子进程确实正
常退出了，则waitpid返回该子进程的PID。waitpid调用失败时返回-1并
设置errno。

&emsp;&emsp;对waitpid函数而言，我们最好在某个子进程退出之后再
调用它。那么父进程从何得知某个子进程已经退出了呢？这正是
SIGCHLD信号的用途。当一个进程结束时，它将给其父进程发送一个
SIGCHLD信号。因此，我们可以在父进程中捕获SIGCHLD信号，并在
信号处理函数中调用waitpid函数以“彻底结束”一个子进程

```
SIGCHLD信号的典型处理函数
static void handle_child(int sig)
{
    pid_t pid;
    int stat;
    while((pid=waitpid(-1,＆stat,WNOHANG))＞0)
    {
    /*对结束的子进程进行善后处理*/
    }
}
```

## 五.进程间通信
### 1.进程间通信概念
进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间
的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。
1. 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程
间通信( IPC：Inter Processes Communication )。
2. 进程间通信的目的：
    * 数据传输：一个进程需要将它的数据发送给另一个进程。
    * 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
    * 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。
    * 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

### 2.进程间通信方式
1. 同一主机通信
    * Unix进程间通信方式 有：匿名管道 有名管道 信号

    * System V进程间通信方式和POSIX进程间通信方式 有：消息队列 共享内存 信号量
2. 不同主机（网络）进程间通信
    *  Socket

### 3.管道(匿名管道, PIPE)
管道也叫无名（匿名）管道，它是是 UNIX 系统 IPC（进程间通信）的最古老形式，所有的 UNIX 系统都支持这种通信机制。
1. 管道的特点
    * 管道其实是一个在**内核内存中维护的缓冲器**，这个缓冲器的存储能力是有限的，不同的
操作系统大小不一定相同。
    * 管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，
但不存储数据。可以按照操作文件的方式对管道进行操作。
    * 一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据
的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。
    * 通过管道传递的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺
序是完全一样的。
    * 在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道是**半双工**的。
    * 从管道读数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写
更多的数据，在管道中无法使用 lseek() 来随机的访问数据。
    * **匿名管道只能在具有公共祖先的进程（父进程与子进程，或者两个兄弟进程，具有亲缘关系）之间使用**。
    * 管道的数据结构是一个循环队列。

2.匿名管道的使用
```
创建匿名管道
#include <unistd.h>
int pipe(int pipefd[2]);

查看管道缓冲大小命令
ulimit –a

查看管道缓冲大小函数
#include <unistd.h>
long fpathconf(int fd, int name);

```

### 4.有名管道(FIFO)
1. 通过命令创建有名管道 `mkfifo 名字`
2. 通过函数创建有名管道
```
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
```
3. 一旦使用 mkfifo 创建了一个 FIFO，就可以使用 open 打开它，常见的文件I/O 函数都可用于 fifo。如：close、read、write、unlink 等。
4. FIFO 严格遵循先进先出（First in First out），对管道及 FIFO 的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek() 等文件定位操作。

### 5.内存映射
内存映射（Memory-mapped I/O）是将磁盘文件的数据映射到内存，用户通过修改
内存就能修改磁盘文件。
```
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);

```

### 6.信号
1. 概念
    * 信号是 Linux 进程间通信的最古老的方式之一，是事件发生时对进程的通知机制，有时也
称之为软件中断，它是在软件层次上对中断机制的一种模拟，是一种异步通信的方式。信号
可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件。
    * 发往进程的诸多信号，通常都是源于内核。引发内核为进程产生信号的各类事件如下：
        * 对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C 
通常会给进程发送一个中断信号。
        * 硬件发生异常，即硬件检测到一个错误条件并通知内核，随即再由内核发送相应信号给
相关进程。比如执行一条异常的机器语言指令，诸如被 0 除，或者引用了无法访问的
内存区域。
        * 系统状态变化，比如 alarm 定时器到期将引起 SIGALRM 信号，进程执行的 CPU 
时间超限，或者该进程的某个子进程退出。
        * 运行 kill 命令或调用 kill 函数。

    * 使用信号的两个主要目的是：
        * 让进程知道已经发生了一个特定的事情。
        * 强迫进程执行它自己代码中的信号处理程序。
    * 信号的特点：
        * 简单
        * 不能携带大量信息
        * 满足某个特定条件才发送
        * 优先级比较高
    * 查看系统定义的信号列表：kill –l 
    * 前 31 个信号为常规信号，其余为实时信号。
    * 查看信号的详细信息：man 7 signal
    * 信号的 5 中默认处理动作
        * Term 终止进程
        * Ign 当前进程忽略掉这个信号
        * Core 终止进程，并生成一个Core文件
        * Stop 暂停当前进程
        * Cont 继续执行当前被暂停的进程
    * 信号的几种状态：产生、未决、递达
    * SIGKILL 和 SIGSTOP 信号不能被捕捉、阻塞或者忽略，只能执行默认动作

2. 信号相关函数
```
int kill(pid_t pid, int sig);
int raise(int sig);
void abort(void);
unsigned int alarm(unsigned int seconds);
int setitimer(int which, const struct itimerval *new_val, 
struct itimerval *old_value);
```

3. 定时器
```
    #include <unistd.h>
    unsigned int alarm(unsigned int seconds);
    #include <sys/time.h>
    int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);
```

4. 信号捕捉信号
```
    sighandler_t signal(int signum, sighandler_t handler);
    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

5. 信号集
    * 许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可使用一个称之为
信号集的数据结构来表示，其系统数据类型为 sigset_t。
    * 在 PCB 中有两个非常重要的信号集。一个称之为 “阻塞信号集” ，另一个称之为
“未决信号集” 。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我
们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数
来对 PCB 中的这两个信号集进行修改。
    * 信号的 “未决” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。
    * 信号的 “阻塞” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。
    * 信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，
所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。

6. 信号集相关的函数
```
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signum);
int sigdelset(sigset_t *set, int signum);
int sigismember(const sigset_t *set, int signum);
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
int sigpending(sigset_t *set);
```
7. SIGCHLD信号
    * SIGCHLD信号产生的条件
        * 子进程终止时
        * 子进程接收到 SIGSTOP 信号停止时
        * 子进程处在停止态，接受到SIGCONT后唤醒时
    * 以上三种条件都会给父进程发送 SIGCHLD 信号，父进程默认会忽略该信号

