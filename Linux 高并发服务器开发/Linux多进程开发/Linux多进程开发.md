# Linux多进程开发
## 一.进程概述
### 1.进程与程序
1. **进程是正在运行的程序的实例**。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。
2. **可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。**从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。
3. **程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：**
    * 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）
    * 机器语言指令：对程序算法进行编码。
    * 程序入口地址：标识程序开始执行时的起始指令位置。
    * 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。
    * 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。
    * 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。
    * 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。
### 2.单道和多道程序设计
1. 单道程序，即在计算机内存中只允许一个的程序运行。
2. 多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。
3. 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。
4. 在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。
### 3.时间片
1. 时间片（timeslice）又称为“量子（quantum）”或“处理器片（processor slice）”是操作系统分配给每个正在运行的进程微观上的一段 CPU 时间。事实上，虽然一台计算机通常可能有多个 CPU，但是同一个 CPU 永远不可能真正地同时运行多个任务。在只考虑一个 CPU 的情况下，这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在 Linux 上为 5ms－800ms），用户不会感觉到。
2. 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。
### 4.并行和并发
1. 并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。
2. 并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。  

**notice:并行的进程也可以并发,并发是两个队列交替使用一台咖啡机。
并行是两个队列同时使用两台咖啡机。**
### **5.进程控制块(PCB)**
1. 为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。
2. 在 /usr/src/linux-headers-xxx/include/linux/sched.h 文件中可以查看 struct task_struct 结构体定义。其内部成员有很多，我们只需要掌握以下部分即可：
    * 进程id：系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数
    * 进程的状态：有就绪、运行、挂起、停止等状态
    * 进程切换时需要保存和恢复的一些CPU寄存器
    * 描述虚拟地址空间的信息
    * 描述控制终端的信息
    * 当前工作目录（Current Working Directory）
    * umask 掩码
    * 文件描述符表，包含很多指向 file 结构体的指针
    * 和信号相关的信息
    * 用户 id 和组 id
    * 会话（Session）和进程组
### 6.进程的状态(5个)
进程状态反映进程执行过程的变化。这些状态随着进程的执行和外界条件的变化而转换。在三态模型中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪态，运行态，阻塞态，终止态。 
1. 运行态：进程占有处理器正在运行
2. 就绪态：进程具备运行条件，等待系统分配处理器以便运
行。当进程已分配到除CPU以外的所有必要资源后，只要再
获得CPU，便可立即执行。在一个系统中处于就绪状态的进
程可能有多个，通常将它们排成一个队列，称为就绪队列
3. 阻塞态：又称为等待(wait)态或睡眠(sleep)态，指进程
不具备运行条件，正在等待某个事件的完成
4. 新建态：进程刚被创建时的状态，尚未进入就绪队列
5. 终止态：进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。

## 二.进程的创建(fork)
系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成
进程树结构模型。
```
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
```

&emsp;&emsp;**该函数的每次调用都返回两次**，在父进程中返回的是子进程的PID， 在子进程中则返回0。该返回值是后续代码判断当前进程是父进程还是子进程的依据。fork调用失败时返回-1，并设置errno。  

&emsp;&emsp;fork函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和标志寄存器的值。但也有许多属性被赋予了新的值，比如该进程的PPID被设置成原进程的PID，信号位图被清除（原进程设置的信号处理函数不再对
新进程起作用）。  

&emsp;&emsp;子进程的代码与父进程完全相同，同时它还会复制父进程的数据（堆数据、栈数据和静态数据）。数据的复制采用的是所谓的写时复制（copy on writte），即只有在任一进程（父进程或子进程）对数据执行了写操作时，复制才会发生（先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据）。即便如此，如果我们在程序中分配了大
量内存，那么使用fork时也应当十分谨慎，尽量避免没必要的内存分配
和数据复制。  

&emsp;&emsp;此外，创建子进程后，父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加1。不仅如此，父进程的用户根目录、当前工作目录等变量的引用计数均会加1。

## 三.exec函数族
&emsp;&emsp;exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件。
```
#include＜unistd.h＞
extern char**environ;
int execl(const char*path,const char*arg,...);
int execlp(const char*file,const char*arg,...);
int execle(const char*path,const char*arg,...,char*const envp[]);
int execv(const char*path,char*const argv[]);
int execvp(const char*file,char*const argv[]);
int execve(const char*path,char*const argv[],char*const envp[]);
l(list) 参数地址列表，以空指针结尾
v(vector) 存有各参数地址的指针数组的地址
p(path) 按 PATH 环境变量指定的目录搜索可执行文件
e(environment) 存有环境变量字符串地址的指针数组的地址
```
&emsp;&emsp;path参数指定可执行文件的完整路径，file参数可以接受文件名，该文件的具体位置则在环境变量PATH中搜寻。arg接受可变参数，argv则接受参数数组，它们都会被传递给新程序（path或file指定的程序）的main函数。envp参数用于设置新程序的环境变量。如果未设置它，则新程序将使用由全局变量environ指定的环境变量。  

&emsp;&emsp;一般情况下，exec函数是不返回的，除非出错。它出错时返回-1，并设置errno。如果没出错，则原程序中exec调用之后的代码都不会执行，因为此时原程序已经被exec的参数指定的程序完全替换（包括代码和数据）。  

&emsp;&emsp;exec函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性。   
## 四.进程的退出和回收原理及可能转化为的状态
### 1.进程退出
```
#include <stdlib.h>
void exit(int status);

#include <unistd.h>
void _exit(int status);

exit是C的库函数，而_exit是Linux的库函数
进程运行->调用退出处理函数->刷新I/O缓冲->关闭文件描述符->调用_exit()系统调用->进程终止运行
或者
进程运行->调用_exit()系统调用->进程终止运行
```

### 2.孤儿进程
1. 父进程运行结束，但子进程还在运行（未运行结束），这样的子进程就称为孤儿进（Orphan Process）。
2. 每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ，而 init 进程会循环地 wait() 它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束
了其生命周期的时候，init 进程就会代表党和政府出面处理它的一切善后工作。
3. 因此孤儿进程并不会有什么危害。

### 3.僵尸进程
1. 每个进程结束之后, 都会释放自己地址空间中的用户区数据，内核区的 PCB 没有办法自己释放掉，需要父进程去释放。
2. 进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸（Zombie）进程。
3. 僵尸进程不能被 kill -9 杀死，这样就会导致一个问题，如果父进程不调用 wait() 或 waitpid() 的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害，应当避免。

### 4.进程回收
1. 在每个进程退出的时候，内核释放该进程所有的资源、包括打开的文件、占用的内存等。但是仍然为其保留一定的信息，这些信息主要主要指进程控制块PCB的信息（包括进程号、退出状态、运行时间等）。
2. 父进程可以通过调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。
3. wait() 和 waitpid() 函数的功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞，waitpid() 还可以指定等待哪个子进程结束。
4. 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。


### 5.wait()和waitpid()函数
```
#include＜sys/types.h＞
#include＜sys/wait.h＞
pid_t wait(int*stat_loc);
pid_t waitpid(pid_t pid,int*stat_loc,int options);
```
&emsp;&emsp;wait函数将阻塞进程，直到该进程的某个子进程结束运行为止。它
返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于
stat_loc参数指向的内存中。sys/wait.h头文件中定义了几个宏来帮助解释子进程的退出状态信息  
* WIFEXITED(status) 非0，进程正常退出
* WEXITSTATUS(status) 如果上宏为真，获取进程退出的状态（exit的参数）
* WIFSIGNALED(status) 非0，进程异常终止
* WTERMSIG(status) 如果上宏为真，获取使进程终止的信号编号
* WIFSTOPPED(status) 非0，进程处于暂停状态
* WSTOPSIG(status) 如果上宏为真，获取使进程暂停的信号的编号
* WIFCONTINUED(status) 非0，进程暂停后已经继续运行


&emsp;&emsp;wait函数的阻塞特性显然不是服务器程序期望的，而waitpid函数解
决了这个问题。waitpid只等待由pid参数指定的子进程。如果pid取值
为-1，那么它就和wait函数相同，即等待任意一个子进程结束。stat_loc
参数的含义和wait函数的stat_loc参数相同。options参数可以控制waitpid函数的行为。该参数最常用的取值是WNOHANG。当options的取值是WNOHANG时，waitpid调用将是非阻塞的：如果pid指定的目标子进程
还没有结束或意外终止，则waitpid立即返回0；如果目标子进程确实正
常退出了，则waitpid返回该子进程的PID。waitpid调用失败时返回-1并
设置errno。

&emsp;&emsp;对waitpid函数而言，我们最好在某个子进程退出之后再
调用它。那么父进程从何得知某个子进程已经退出了呢？这正是
SIGCHLD信号的用途。当一个进程结束时，它将给其父进程发送一个
SIGCHLD信号。因此，我们可以在父进程中捕获SIGCHLD信号，并在
信号处理函数中调用waitpid函数以“彻底结束”一个子进程

```
SIGCHLD信号的典型处理函数
static void handle_child(int sig)
{
    pid_t pid;
    int stat;
    while((pid=waitpid(-1,＆stat,WNOHANG))＞0)
    {
    /*对结束的子进程进行善后处理*/
    }
}
```

## 五.进程间通信
### 1.进程间通信概念
进程是一个独立的资源分配单元，不同进程（这里所说的进程通常指的是用户进程）之间
的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源。
1. 但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等，因此需要进程
间通信( IPC：Inter Processes Communication )。
2. 进程间通信的目的：
    * 数据传输：一个进程需要将它的数据发送给另一个进程。
    * 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。
    * 资源共享：多个进程之间共享同样的资源。为了做到这一点，需要内核提供互斥和同步机制。
    * 进程控制：有些进程希望完全控制另一个进程的执行（如 Debug 进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。

    

